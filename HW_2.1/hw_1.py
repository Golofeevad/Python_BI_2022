# -*- coding: utf-8 -*-
"""HW_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MEqRMEiBLQEpF9K_s8C_Fp0r1_lMlycM

# Задание 1 (5 баллов)

Напишите классы **Chat**, **Message** и **User**. Они должны соответствовать следующим требованиям:

**Chat**:
+ Должен иметь атрибут `chat_history`, где будут храниться все сообщения (`Message`) в обратном хронологическом порядке (сначала новые, затем старые)
+ Должен иметь метод `show_last_message`, выводящий на экран информацию о последнем сообщении
+ Должен иметь метод `get_history_from_time_period`, который принимает два опциональных аргумента (даты с которой и по какую мы ищем сообщения и выдаём их). Метод также должен возвращать объект типа `Chat`
+ Должен иметь метод `show_chat`, выводящий на экран все сообщения (каждое сообщение в таком же виде как и `show_last_message`, но с разделителем между ними)
+ Должен иметь метод `recieve`, который будет принимать сообщение и добавлять его в чат

**Message**:
+ Должен иметь три обязательных атрибута
    + `text` - текст сообщения
    + `datetime` - дата и время сообщения (встроенный модуль datetime вам в помощь). Важно! Это должна быть не дата создания сообщения, а дата его попадания в чат! 
    + `user` - информация о пользователе, который оставил сообщение (какой тип данных использовать здесь, разберётесь сами)
+ Должен иметь метод `show`, который печатает или возвращает информацию о сообщении с необходимой информацией (дата, время, юзер, текст)
+ Должен иметь метод `send`, который будет отправлять сообщение в чат

**User**:
+ Класс с информацией о юзере, наполнение для этого класса придумайте сами

Напишите несколько примеров использования кода, которое показывает взаимодействие между объектами.

В тексте задания намерено не указано, какие аргументы должны принимать методы, пускай вам в этом поможет здравый смысл)

В этом задании не стоит флексить всякими продвинутыми штуками, для этого есть последующие

В этом задании можно использовать только модуль `datetime`
"""

from datetime import datetime

class Chat:
    def __init__(self, messages=None):
        if messages is None:
            self.chat_history = [Message('Your chat started!', User('Admin', None, None), datetime.now())]
        else:
            self.chat_history = messages

    def show_last_message(self):
            self.chat_history[0].show()

    def get_history_from_time_period(self, start_time=None, end_time=None):
        if start_time is None and end_time is None:
            return self
        elif start_time > self.chat_history[0].datetime or end_time < self.chat_history[-1].datetime or start_time > end_time:
            raise ValueError(f"Incorrect dates interval")
        else:
            chat_history = [msg for msg in self.chat_history if start_time <= msg.datetime <= end_time]
            return Chat(chat_history)

    def show_chat(self):
        for msg in self.chat_history:
            msg.show()
            print()

    def receive(self, msg):
        msg.datetime = datetime.now()
        self.chat_history.insert(0, msg)

class Message:

    def __init__(self, text, user, chat_datetime=None):
        self.text = text
        self.user = user
        self.datetime = chat_datetime

    def show(self):
        print(f'The text of message: {self.text} \n'
              f'The date and time of message: {self.datetime} \n'
              f'Written by {self.user.username}')

    def send(self, chat):
        chat.receive(self)

class User:
    def __init__(self, username, name, lastname):
        self.username = username
        self.name = name
        self.lastname = lastname

user1 = User('Joey_Tribbiani', 'Joey', 'Tribbiani')
user2 = User('Monica_Geller', 'Monica', 'Geller')
user1_user2_chat =  Chat()
message1 = Message('Some girl ate Monica!', user1)
message2 = Message('Shut up! The camera adds ten pounds!', user2)
message3  = Message('So how many cameras are actually on you?', user1)

message1.send(user1_user2_chat)

message2.send(user1_user2_chat)

message3.send(user1_user2_chat)

user1_user2_chat.show_chat()

time_period_chat = user1_user2_chat.get_history_from_time_period()
time_period_chat.show_last_message()

time_period_chat = user1_user2_chat.get_history_from_time_period(start_time=datetime(2023, 2, 24, 10, 42, 55),
    end_time=datetime(2023, 2, 24, 10, 43, 3))

time_period_chat.show_chat()

"""# Задание 2 (3 балла)

В питоне как-то слишком типично и неинтересно происходят вызовы функций. Напишите класс `Args`, который будет хранить в себе аргументы, а функции можно будет вызывать при помощи следующего синтаксиса.

Использовать любые модули **нельзя**, да и вряд-ли это как-то поможет)
"""

class Args:

    def __init__(self, *args, **kwargs):
        self.__args = args
        self.__kwargs = kwargs

    def __rlshift__(self, other):
        return other(*self.__args, **self.__kwargs)

sum << Args([1, 2])

(lambda a, b, c: a**2 + b + c) << Args(1, 2, c=50)

"""# Задание 3 (5 баллов)

Сделайте класс наследник `float`. Он должен вести себя как `float`, но также должен обладать некоторыми особенностями:
+ При получении атрибутов формата `<действие>_<число>` мы получаем результат такого действия над нашим числом
+ Создавать данные атрибуты в явном виде, очевидно, не стоит

Подсказка: если в процессе гуглёжки, вы выйдете на такую тему как **"Дескрипторы", то это НЕ то, что вам сейчас нужно**

Примеры использования ниже
"""

class StrangeFloat(float):
    def __init__(self, val):
        super(StrangeFloat, self).__init__()
        self.val = val

    def __getattribute__(self, name):
        try:
            action, arg = name.split("_")
            arg = float(arg)
        except ValueError:
            return super().__getattribute__(name)

        if action == "add":
            return StrangeFloat(self.val + arg)
        elif action == "subtract":
            return StrangeFloat(self.val - arg)
        elif action == "multiply":
            return StrangeFloat(self.val * arg)
        elif action == "divide":
            return StrangeFloat(self.val / arg)
        else:
            raise NotImplementedError(f'No action called {action}')

number = StrangeFloat(3.5)

number.add_1

number.subtract_20

number.multiply_5

number.divide_25

number.add_1.add_2.multiply_6.divide_8.subtract_9

getattr(number, "add_-2.5")   # Используем getattr, так как не можем написать number.add_-2.5 - это SyntaxError

number + 8   # Стандартные для float операции работают также

number.as_integer_ratio()   # Стандартные для float операции работают также  (это встроенный метод float, писать его НЕ НАДО)

"""# Задание 4 (3 балла)

В данном задании мы немного отдохнём и повеселимся. От вас требуется заменить в данном коде максимально возможное количество синтаксических конструкций на вызовы dunder методов, dunder атрибутов и dunder переменных.

Маленькая заметка: полностью всё заменить невозможно. Например, `function()` можно записать как `function.__call__()`, но при этом мы всё ещё не избавляемся от скобочек, так что можно делать так до бесконечности `function.__call__.__call__.__call__.__call__.....__call__()` и при всём при этом мы ещё не избавляемся от `.` для доступа к атрибутам. В общем, замените всё, что получится, не закапываясь в повторы, как в приведённом примере. Чем больше разных методов вы найдёте и используете, тем лучше и тем выше будет балл

Код по итогу дожен работать и печатать число **4420.0**, как в примере. Структуру кода менять нельзя, просто изменяем конструкции на синонимичные

И ещё маленькая подсказка. Заменить здесь можно всё кроме:
+ Конструкции `for ... in ...`:
+ Синтаксиса создания лямбда функции
+ Оператора присваивания `=`
+ Конструкции `if-else`
"""

import numpy as np

matrix = []
for idx in range(0, 100, 10):
    matrix += [list(range(idx, idx + 10))]
    
selected_columns_indices = list(filter(lambda x: x in range(1, 5, 2), range(len(matrix))))
selected_columns = map(lambda x: [x[col] for col in selected_columns_indices], matrix)

arr = np.array(list(selected_columns))

mask = arr[:, 1] % 3 == 0
new_arr = arr[mask]

product = new_arr @ new_arr.T

if (product[0] < 1000).all() and (product[2] > 1000).any():
    print(product.mean())

matrix = list.__new__(list)
for idx in range.__call__(0, 100, 10):
    matrix.__iadd__([list.__call__(range(idx, idx.__add__(10)))])

selected_columns_indices = list.__call__(filter.__call__(lambda x: x in range(1, 5, 2), range(matrix.__len__())))
selected_columns = map.__call__(lambda x: list.__call__(x.__getitem__(col) for col in selected_columns_indices), matrix)
arr = np.array(list.__call__(selected_columns))

mask = arr.__getitem__((slice(None), 1)).__mod__(3).__eq__(0)
new_arr = arr.__getitem__(mask)

product = new_arr.__matmul__(new_arr.T)

if product.__getitem__(0).__lt__(1000).__eq__(True).__and__(product.__getitem__(2).__gt__(1000)).__contains__(True):
    print(product.mean().__repr__())

"""# Задание 5 (10 баллов)

Напишите абстрактный класс `BiologicalSequence`, который задаёт следующий интерфейс:
+ Работа с функцией `len`
+ Возможность получать элементы по индексу и делать срезы последовательности (аналогично строкам)
+ Вывод на печать в удобном виде и возможность конвертации в строку
+ Возможность проверить алфавит последовательности на корректность

Напишите класс `NucleicAcidSequence`:
+ Данный класс реализует интерфейс `BiologicalSequence`
+ Данный класс имеет новый метод `complement`, возвращающий комплементарную последовательность
+ Данный класс имеет новый метод `gc_content`, возвращающий GC-состав (без разницы, в процентах или в долях)

Напишите классы наследники `NucleicAcidSequence`: `DNASequence` и `RNASequence`
+ `DNASequence` должен иметь метод `transcribe`, возвращающий транскрибированную РНК-последовательность
+ Данные классы не должны иметь <ins>публичных методов</ins> `complement` и метода для проверки алфавита, так как они уже должны быть реализованы в `NucleicAcidSequence`.

Напишите класс `AminoAcidSequence`:
+ Данный класс реализует интерфейс `BiologicalSequence`
+ Добавьте этому классу один любой метод, подходящий по смыслу к аминокислотной последовательности. Например, метод для нахождения изоэлектрической точки, молекулярного веса и т.д.

Комментарий по поводу метода `NucleicAcidSequence.complement`, так как я хочу, чтобы вы сделали его опредедённым образом:

При вызове `dna.complement()` или условного `dna.check_alphabet()` должны будут вызываться соответствующие методы из `NucleicAcidSequence`. При этом, данный метод должен обладать свойством полиморфизма, иначе говоря, внутри `complement` не надо делать условия а-ля `if seuqence_type == "DNA": return self.complement_dna()`, это крайне не гибко. Данный метод должен опираться на какой-то общий интерфейс между ДНК и РНК. Создание экземпляров `NucleicAcidSequence` не подразумевается, поэтому код `NucleicAcidSequence("ATGC").complement()` не обязан работать, а в идеале должен кидать исключение `NotImplementedError` при вызове от экземпляра `NucleicAcidSequence`

Вся сложность задания в том, чтобы правильно организовать код. Если у вас есть повторяющийся код в сестринских классах или родительском и дочернем, значит вы что-то делаете не так.


Маленькое замечание: По-хорошему, между классом `BiologicalSequence` и классами `NucleicAcidSequence` и `AminoAcidSequence`, ещё должен быть класс-прослойка, частично реализующий интерфейс `BiologicalSequence`, но его писать не обязательно, так как задание и так довольно большое (правда из-за этого у вас неминуемо возникнет повторяющийся код в классах `NucleicAcidSequence` и `AminoAcidSequence`)
"""

from abc import ABC, abstractmethod

class NotInAlphabetException(Exception):
    pass

class BiologicalSequence(ABC):

    def __init__(self, seq):
        self.seq = seq.lower()

    def __len__(self):
        return len(self.seq)

    def __getitem__(self, item):
        return self.seq.__getitem__(item)

    def __str__(self):
        return self.seq

    def print(self):
        print(self.seq)

    @abstractmethod
    def check_alphabet(self):
        pass


class AlphabetAwareSequence(BiologicalSequence, ABC):

    def __init__(self, seq, alphabet):
        super(AlphabetAwareSequence, self).__init__(seq)
        self.alphabet = alphabet

    def check_alphabet(self):
        for i in self.seq:
            if i not in self.alphabet:
                return False
        return True


class NucleicAcidSequence(AlphabetAwareSequence, ABC):

    def __init__(self, seq, alphabet, complements):
        super(NucleicAcidSequence, self).__init__(seq, alphabet)
        self.alphabet = alphabet
        self.complements = complements

    def complement(self):
        try:
            return NucleicAcidSequence("".join(map(lambda i: self.complements[i], self.seq)), self.alphabet, self.complements)
        except KeyError as e:
            raise NotInAlphabetException from e

    def gc_content(self):
        return sum(map(lambda a: a == "g" or a == "c", self.seq)) / len(self.seq)


dnaAlphabet = 'atgc'
dnaComplements = {'a':'t', 't':'a', 'g':'c', 'c':'g'}
dnaTranscribes = {'a':'u', 'g':'c', 'c':'g', 't':'a'}
class DNASequence(NucleicAcidSequence):

    def __init__(self, seq):
        super(DNASequence, self).__init__(seq, dnaAlphabet, dnaComplements)

    def transcribe(self):
        try:
            return RNASequence("".join(map(lambda i: dnaTranscribes[i], self.seq)))
        except KeyError as e:
            raise NotInAlphabetException from e


rnaAlphabet = 'augc'
rnaComplements = {'a':'u', 'u':'a', 'g':'c', 'c':'g'}
class RNASequence(NucleicAcidSequence):

    def __init__(self, seq):
        super(RNASequence, self).__init__(seq, rnaAlphabet, rnaComplements)


aminoacidAlphabet = 'ACDEFGHIKLMNPQRSTVWY'
aminoacid_weights = {
    "a": 89.09,
    "c": 121.16,
    "d": 133.10,
    "e": 147.13,
    "f": 165.19,
    "g": 75.07,
    "h": 155.16,
    "i": 131.17,
    "k": 146.19,
    "l": 131.17,
    "m": 149.21,
    "n": 132.12,
    "p": 115.13,
    "q": 146.15,
    "r": 174.20,
    "s": 105.09,
    "t": 119.12,
    "v": 117.15,
    "w": 204.23,
    "y": 181.19,
}
class AminoAcidSequence(AlphabetAwareSequence):

    def __init__(self, seq):
        super(AminoAcidSequence, self).__init__(seq, aminoacidAlphabet)

    def __rep__(self):
        return f"NH2-{self.seq}-COOH"

    def weight(self):
        try:
            return sum(map(lambda i: aminoacid_weights[i], self.seq))
        except KeyError as e:
            raise NotInAlphabetException from e

dna = DNASequence('atgccgtaagccg')
dna.print()

dna.complement().print()

dna.transcribe().print()

dna.gc_content()

AminoAcidSequence("KLWYSTV").weight()