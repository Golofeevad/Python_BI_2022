# -*- coding: utf-8 -*-
"""HW_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/121xL8aWPxBnlim-9DQnrM81YxzF-7qqc

# Задание 1 (6 баллов)

В данном задании мы будем работать со [списком 250 лучших фильмов IMDb](https://www.imdb.com/chart/top/?ref_=nv_mp_mv250)

1. Выведите топ-4 *фильма* **по количеству оценок пользователей** и **количество этих оценок** (1 балл)
2. Выведите топ-4 лучших *года* (**по среднему рейтингу фильмов в этом году**) и **средний рейтинг** (1 балл)
3. Постройте отсортированный **barplot**, где показано **количество фильмов** из списка **для каждого режисёра** (только для режиссёров с более чем 2 фильмами в списке) (1 балл)
4. Выведите топ-4 самых популярных *режиссёра* (**по общему числу людей оценивших их фильмы**) (2 балла)
5. Сохраните данные по всем 250 фильмам в виде таблицы с колонками (name, rank, year, rating, n_reviews, director) в любом формате (2 балла)

Использовать можно что-угодно, но полученные данные должны быть +- актуальными на момент сдачи задания
"""

# Ваше решение здесь
import csv
import datetime
import http.client
import json
import os
import requests
from io import StringIO
from heapq import nlargest
from dotenv import load_dotenv
from itertools import groupby
import matplotlib.pyplot as plt

load_dotenv()

imdb_api_key = os.getenv("IMDB_API_KEY")
conn = http.client.HTTPSConnection("imdb-api.com", 443)
payload = ''
headers = {}
conn.request("GET", f"/en/API/Top250Movies/{imdb_api_key}", payload, headers)
res = conn.getresponse()
data_json = res.read().decode("utf-8")
top_movies = json.loads(data_json)['items']

most_rated = nlargest(4, top_movies, lambda movie: int(movie['imDbRatingCount']))
print('Most rated movies:')
print("\n".join(map(lambda movie: f"{movie['title']}: {movie['imDbRatingCount']} rates", most_rated)))


grouped_by_year = sorted(top_movies, key=lambda movie: movie['year'])
grouped_by_year = groupby(grouped_by_year, lambda movie: movie['year'])

def mean_rating(year_and_movies):
    year, movies = year_and_movies
    movies_list = list(movies)
    mean = sum(float(movie['imDbRating']) for movie in movies_list) / len(movies_list)
    return year, mean

year_with_mean_rating = map(mean_rating, grouped_by_year)
most_rated_years = nlargest(4, year_with_mean_rating, lambda year_and_mean: year_and_mean[1])
print('Most rated years:')
print("\n".join(map(lambda year_and_mean: f"{year_and_mean[0]}: average {year_and_mean[1]}", most_rated_years)))


def get_director(movie):
    return movie['crew'].split(' (dir.)')[0]
grouped_by_director = sorted(top_movies, key=get_director)
grouped_by_director = groupby(grouped_by_director, get_director)
def hot_calculation(element):
    key, elements = element
    return key, list(elements)
grouped_by_director = map(hot_calculation, grouped_by_director)
grouped_by_director = list(grouped_by_director)

def movies_number_by_director(director_and_movies):
    director, movies = director_and_movies
    return director, len(movies)

directors_with_films = map(movies_number_by_director, grouped_by_director)
directors_with_many_films = filter(lambda director_and_movies_number: director_and_movies_number[1] > 2, directors_with_films)
sorted_directors_with_many_films = list(sorted(directors_with_many_films, key=lambda item: item[1]))

directors = list(map(lambda item: item[0], sorted_directors_with_many_films))
films_number = list(map(lambda item: item[1], sorted_directors_with_many_films))
plt.bar(directors, films_number)
plt.xticks(rotation=30, ha='right')
plt.show()


def total_rates(director_and_movies):
    director, movies = director_and_movies
    total = sum(int(movie['imDbRatingCount']) for movie in movies)
    return director, total
    
directors_with_rates = map(total_rates, grouped_by_director) 
most_rated_directors = nlargest(4, directors_with_rates, lambda director_with_rate: director_with_rate[1])
print('Most rated directors:')
print("\n".join(map(lambda director_with_rate: f"{director_with_rate[0]}: total {director_with_rate[1]}", most_rated_directors)))


def create_saving_data(movie):
    return [movie['title'], movie['rank'], movie['year'], movie['imDbRating'], movie['imDbRatingCount'], get_director(movie)]
saving_data = map(create_saving_data, top_movies)
header = ['name', 'rank', 'year', 'rating', 'n_reviews', 'director']
with open('data/movies.csv', 'w', encoding='UTF8', newline='') as f:
    writer = csv.writer(f)
    writer.writerow(header)
    writer.writerows(saving_data)

"""# Задание 2 (10 баллов)

Напишите декоратор `telegram_logger`, который будет логировать запуски декорируемых функций и отправлять сообщения в телеграм.


Вся информация про API телеграм ботов есть в официальной документации, начать изучение можно с [этой страницы](https://core.telegram.org/bots#how-do-bots-work) (разделы "How Do Bots Work?" и "How Do I Create a Bot?"), далее идите в [API reference](https://core.telegram.org/bots/api)

**Основной функционал:**
1. Декоратор должен принимать **один обязательный аргумент** &mdash; ваш **CHAT_ID** в телеграме. Как узнать свой **CHAT_ID** можно найти в интернете
2. В сообщении об успешно завершённой функции должны быть указаны её **имя** и **время выполнения**
3. В сообщении о функции, завершившейся с исключением, должно быть указано **имя функции**, **тип** и **текст ошибки**
4. Ключевые элементы сообщения должны быть выделены **как код** (см. скриншот), форматирование остальных элементов по вашему желанию
5. Время выполнения менее 1 дня отображается как `HH:MM:SS.μμμμμμ`, время выполнения более 1 дня как `DDD days, HH:MM:SS`. Писать форматирование самим не нужно, всё уже где-то сделано за вас

**Дополнительный функционал:**
1. К сообщению также должен быть прикреплён **файл**, содержащий всё, что декорируемая функция записывала в `stdout` и `stderr` во время выполнения. Имя файла это имя декорируемой функции с расширением `.log` (**+3 дополнительных балла**)
2. Реализовать предыдущий пункт, не создавая файлов на диске (**+2 дополнительных балла**)
3. Если функция ничего не печатает в `stdout` и `stderr` &mdash; отправлять файл не нужно

**Важные примечания:**
1. Ни в коем случае не храните свой API токен в коде и не загружайте его ни в каком виде свой в репозиторий. Сохраните его в **переменной окружения** `TG_API_TOKEN`, тогда его можно будет получить из кода при помощи `os.getenv("TG_API_TOKEN")`. Ручное создание переменных окружения может быть не очень удобным, поэтому можете воспользоваться функцией `load_dotenv` из модуля [dotenv](https://pypi.org/project/python-dotenv/). В доке всё написано, но если коротко, то нужно создать файл `.env` в текущей папке и записать туда `TG_API_TOKEN=<your_token>`, тогда вызов `load_dotenv()` создаст переменные окружения из всех переменных в файле. Это довольно часто используемый способ хранения ключей и прочих приватных данных
2. Функцию `long_lasting_function` из примера по понятным причинам запускать не нужно. Достаточно просто убедится, что большие временные интервалы правильно форматируются при отправке сообщения (как в примерах)
3. Допустима реализация логирования, когда логгер полностью перехватывает запись в `stdout` и `stderr` (то есть при выполнении функций печать происходит **только** в файл)
4. В реальной жизни вам не нужно использовать Telegram API при помощи ручных запросов, вместо этого стоит всегда использовать специальные библиотеки Python, реализующие Telegram API, они более высокоуровневые и удобные. В данном задании мы просто учимся работать с API при помощи написания велосипеда.
5. Обязательно прочтите часть конспекта лекции про API перед выполнением задания, так как мы довольно поверхностно затронули это на лекции

**Рекомендуемые к использованию модули:**
1. os
2. sys
3. io
4. datetime
5. requests
6. dotenv

**Запрещённые модули**:
1. Любые библиотеки, реализующие Telegram API в Python (*python-telegram-bot, Telethon, pyrogram, aiogram, telebot* и так далле...)
2. Библиотеки, занимающиеся "перехватыванием" данных из `stdout` и `stderr` (*pytest-capturelog, contextlib, logging*  и так далле...)



Результат запуска кода ниже должен быть примерно такой:

![image.png](attachment:620850d6-6407-4e00-8e43-5f563803d7a5.png)

![image.png](attachment:65271777-1100-44a5-bdd2-bcd19a6f50a5.png)

![image.png](attachment:e423686d-5666-4d81-8890-41c3e7b53e43.png)
"""

import sys
import time

telegram_bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
telegram_chat_id = os.getenv('TELEGRAM_CHAT_ID')

def telegram_logger(chat_id):

    def wrapper(func):
        def logger_function(*args, **kwargs):
            prev_stdout = sys.stdout
            prev_stderr = sys.stderr
            out_buffer = StringIO()
            err_buffer = StringIO()
            sys.stdout = out_buffer
            sys.stderr = err_buffer
            start_time = time.monotonic()
            try:
                res = func(*args, **kwargs)
                end_time = time.monotonic()
                out_logs = out_buffer.getvalue()
                err_logs = err_buffer.getvalue()
                elapsed_time = datetime.timedelta(seconds=end_time - start_time)
                elapsed_time_formatted = str(elapsed_time)
                try:
                    message_text = f"Function `{func.__name__}` was executed in `{elapsed_time_formatted}`"
                    send_message(message_text, err_logs, out_logs)
                finally:
                    return res

            except Exception as e:
                end_time = time.monotonic()
                out_logs = out_buffer.getvalue()
                err_logs = err_buffer.getvalue()
                elapsed_time = datetime.timedelta(seconds=end_time - start_time)
                elapsed_time_formatted = str(elapsed_time)
                try:
                    message_text = f"Function `{func.__name__}` was executed in `{elapsed_time_formatted}`" \
                                   f" with exception `{type(e)}`: `{e.__str__()}`"
                    send_message(message_text, err_logs, out_logs)
                finally:
                    raise
            finally:
                sys.stdout = prev_stdout
                sys.stderr = prev_stderr
                out_buffer.close()
                err_buffer.close()
                sys.stdout.write(out_logs)
                sys.stderr.write(err_logs)

        def send_message(message_text, err_logs, out_logs):
            total_logs = out_logs + err_logs
            if total_logs:
                params = {
                    'chat_id': chat_id,
                    'caption': message_text,
                    'parse_mode': 'MarkdownV2'
                }
                document = (f'{func.__name__}.log', total_logs)
                requests.get(f"https://api.telegram.org/bot{telegram_bot_token}/sendDocument", data=params,
                             files={"document": document})
            else:
                params = {
                    'chat_id': chat_id,
                    'text': message_text,
                    'parse_mode': 'MarkdownV2'
                }
                requests.get(f"https://api.telegram.org/bot{telegram_bot_token}/sendMessage", data=params)

        return logger_function

    return wrapper

@telegram_logger(telegram_chat_id)
def good_function():
    print("This goes to stdout")
    print("And this goes to stderr", file=sys.stderr)
    time.sleep(2)
    print("Wake up, Neo")

@telegram_logger(telegram_chat_id)
def bad_function():
    print("Some text to stdout")
    time.sleep(2)
    print("Some text to stderr", file=sys.stderr)
    raise RuntimeError("Ooops, exception here!")
    print("This text follows exception and should not appear in logs")
    
@telegram_logger(telegram_chat_id)
def long_lasting_function():
    time.sleep(200000000)


good_function()

try:
    bad_function()
except Exception:
    pass

# long_lasting_function()

"""# Задание 3

В данном задании от вас потребуется сделать Python API для какого-либо сервиса

В задании предложено два варианта: простой и сложный, **выберите только один** из них.

Можно использовать только **модули стандартной библиотеки** и **requests**. Любые другие модули можно по согласованию с преподавателем.

❗❗❗ В **данном задании** требуется оформить код в виде отдельного модуля (как будто вы пишете свою библиотеку). Код в ноутбуке проверяться не будет ❗❗❗

## Вариант 1 (простой, 10 баллов)

В данном задании вам потребуется сделать Python API для сервиса http://hollywood.mit.edu/GENSCAN.html

Он способен находить и вырезать интроны в переданной нуклеотидной последовательности. Делает он это не очень хорошо, но это лучше, чем ничего. К тому же у него действительно нет публичного API.

Реализуйте следующую функцию:
`run_genscan(sequence=None, sequence_file=None, organism="Vertebrate", exon_cutoff=1.00, sequence_name="")` &mdash; выполняет запрос аналогичный заполнению формы на сайте. Принимает на вход все параметры, которые можно указать на сайте (кроме Print options). `sequence` &mdash; последовательность в виде строки или любого удобного вам типа данных, `sequence_file` &mdash; путь к файлу с последовательностью, который может быть загружен и использован вместо `sequence`. Функция должна будет возвращать объект типа `GenscanOutput`. Про него дальше.

Реализуйте **датакласс** `GenscanOutput`, у него должны быть следующие поля:
+ `status` &mdash; статус запроса
+ `cds_list` &mdash; список предсказанных белковых последовательностей с учётом сплайсинга (в самом конце результатов с сайта)
+ `intron_list` &mdash; список найденных интронов. Один интрон можно представить любым типом данных, но он должен хранить информацию о его порядковом номере, его начале и конце. Информацию о интронах можно получить из первой таблицы в результатах на сайте.
+ `exon_list` &mdash; всё аналогично интронам, но только с экзонами.

По желанию можно добавить любые данные, которые вы найдёте в результатах
"""

# Не пиши код здесь, сделай отдельный модуль

"""## Вариант 2 (очень сложный, 20 дополнительных баллов)

В этом варианте от вас потребуется сделать Python API для BLAST, а именно для конкретной вариации **tblastn** https://blast.ncbi.nlm.nih.gov/Blast.cgi?PROGRAM=tblastn&PAGE_TYPE=BlastSearch&LINK_LOC=blasthome

Хоть у BLAST и есть десктопное приложение, всё-таки есть одна область, где API может быть полезен. Если мы хотим искать последовательность в полногеномных сборках (WGS), а не в базах данных отдельных генов, у нас могут возникнуть проблемы. Так как если мы хотим пробластить нашу последовательность против большого количества геномов нам пришлось бы или вручную отправлять запросы на сайте, или скачивать все геномы и делать поиск локально. И тот и другой способы не очень удобны, поэтому круто было бы иметь способ сделать автоматический запрос, не заходя в браузер.

Необходимо написать функцию для запроса, которая будет принимать 3 обязательных аргумента: **белковая последовательность**, которую мы бластим, **базу данных** (в этом задании нас интересует только WGS, но по желанию можете добавить какую-нибудь ещё), **таксон**, у которого мы ищем последовательность, чаще всего &mdash; конкретный вид. По=желанию можете добавить также любые другие аргументы, соответствующие различным настройкам поиска на сайте. 

Функция дожна возвращать список объектов типа `Alignment`, у него должны быть следующие атрибуты (всё согласно результатам в браузере, удобно посмотреть на рисунке ниже), можно добавить что-нибудь своё:

![Alignment.png](attachment:e45d0969-ff95-4d4b-8bbc-7f5e481dcda3.png)


Самое сложное в задании - правильно сделать запрос. Для этого нужно очень глубоко погрузиться в то, что происходит при отправке запроса при помощи инструмента для разработчиков. Ещё одна проблема заключается в том, что BLAST не отдаёт результаты сразу, какое-то время ваш запрос обрабатывается, при этом изначальный запрос не перекидывает вас на страницу с результатами. Задание не такое простое как кажется из описания!
"""

# Не пиши код здесь, сделай отдельный модуль